<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cusp: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Algorithms</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__blas.html">BLAS</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SourceType , typename DestinationType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga454fc62c097af3e46f768850a8e6cd66">cusp::convert</a> (const SourceType &amp;src, DestinationType &amp;dst)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga74fcfc1486aa8b2311631f60c0bda938">cusp::copy</a> (const T1 &amp;src, T2 &amp;dst)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga2dda10086e2294bbc27850d57ad6aa13">cusp::add</a> (const Matrix1 &amp;A, const Matrix2 &amp;B, Matrix3 &amp;C)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga4eea276fe0d7ae5048e28e3507bdd472">cusp::subtract</a> (const Matrix1 &amp;A, const Matrix2 &amp;B, Matrix3 &amp;C)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename Array &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#gaa96752a2c6c23c88944fa6d0660763e7">cusp::graph::maximal_independent_set</a> (const Matrix &amp;A, Array &amp;stencil, size_t k=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LinearOperator , typename MatrixOrVector1 , typename MatrixOrVector2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga9ebf00a9f894c28ef6cbf01dabd475d1">cusp::multiply</a> (LinearOperator &amp;A, MatrixOrVector1 &amp;B, MatrixOrVector2 &amp;C)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithms.html#ga9480a952c060ef793a8f84227f1df43c">cusp::transpose</a> (const MatrixType1 &amp;A, MatrixType2 &amp;At)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2dda10086e2294bbc27850d57ad6aa13"></a><!-- doxytag: member="cusp::add" ref="ga2dda10086e2294bbc27850d57ad6aa13" args="(const Matrix1 &amp;A, const Matrix2 &amp;B, Matrix3 &amp;C)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cusp::add </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix3 &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>add</code> : Compute the sum of two matrices </p>

</div>
</div>
<a class="anchor" id="ga454fc62c097af3e46f768850a8e6cd66"></a><!-- doxytag: member="cusp::convert" ref="ga454fc62c097af3e46f768850a8e6cd66" args="(const SourceType &amp;src, DestinationType &amp;dst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SourceType , typename DestinationType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cusp::convert </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestinationType &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>copy</code> : Convert between matrix formats</p>
<dl class="note"><dt><b>Note:</b></dt><dd>DestinationType will be resized as necessary</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>cusp::copy</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga74fcfc1486aa8b2311631f60c0bda938"></a><!-- doxytag: member="cusp::copy" ref="ga74fcfc1486aa8b2311631f60c0bda938" args="(const T1 &amp;src, T2 &amp;dst)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cusp::copy </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>copy</code> : Copy one array or matrix to another</p>
<dl class="note"><dt><b>Note:</b></dt><dd>T1 and T2 must have the same format type </dd>
<dd>
T2 will be resized as necessary</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>convert</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa96752a2c6c23c88944fa6d0660763e7"></a><!-- doxytag: member="cusp::graph::maximal_independent_set" ref="gaa96752a2c6c23c88944fa6d0660763e7" args="(const Matrix &amp;A, Array &amp;stencil, size_t k=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix , typename Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t cusp::graph::maximal_independent_set </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&nbsp;</td>
          <td class="paramname"> <em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>k</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>maximal_independent_set</code> : computes a maximal independent set (MIS) a graph. The MIS is a set of vertices such that (1) no two vertices are adjacent and (2) it is not possible to add another vertex to thes set without violating the first property. The MIS(k) is a generalization of the MIS with the property that no two vertices in the set are joined by a path of <code>k</code> edges or less. The standard MIS is therefore a MIS(1).</p>
<p>The MIS(k) is represented by an array of {0,1} values. Specifically, <code>stencil[i]</code> is 1 if vertex <code>i</code> is a member of the MIS(k) and 0 otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>symmetric matrix that represents a graph </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stencil</em>&nbsp;</td><td>array to hold the MIS(k) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>radius of independence</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Matrix</em>&nbsp;</td><td>matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Array</em>&nbsp;</td><td>array</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://en.wikipedia.org/wiki/Maximal_independent_set">http://en.wikipedia.org/wiki/Maximal_independent_set</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ebf00a9f894c28ef6cbf01dabd475d1"></a><!-- doxytag: member="cusp::multiply" ref="ga9ebf00a9f894c28ef6cbf01dabd475d1" args="(LinearOperator &amp;A, MatrixOrVector1 &amp;B, MatrixOrVector2 &amp;C)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LinearOperator , typename MatrixOrVector1 , typename MatrixOrVector2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cusp::multiply </td>
          <td>(</td>
          <td class="paramtype">LinearOperator &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixOrVector1 &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixOrVector2 &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>multiply</code> : Implements matrix-matrix and matrix-vector multiplication</p>
<p><code>multiply</code> can be used with dense matrices, sparse matrices, and user-defined <code><a class="el" href="classcusp_1_1linear__operator.html">linear_operator</a></code> objects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>input matrix or vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>output matrix or vector</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>LinearOperator</em>&nbsp;</td><td>matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MatrixOrVector1</em>&nbsp;</td><td>matrix or vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MatrixOrVector2</em>&nbsp;</td><td>matrix or vector</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>multiply</code> to compute a matrix-vector product.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="multiply_8h.html" title="Matrix multiplication.">cusp/multiply.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="array2d_8h.html" title="Two-dimensional array.">cusp/array2d.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="print_8h.html" title="Print textual representation of an object.">cusp/print.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
  {
      <span class="comment">// initialize matrix</span>
      <a class="code" href="classcusp_1_1array2d.html">cusp::array2d&lt;float, cusp::host_memory&gt;</a> A(2,2);
      A(0,0) = 10;  A(0,1) = 20;
      A(1,0) = 40;  A(1,1) = 50;
  
      <span class="comment">// initialize input vector</span>
      <a class="code" href="classcusp_1_1array1d.html">cusp::array1d&lt;float, cusp::host_memory&gt;</a> x(2);
      x[0] = 1;
      x[1] = 2;
  
      <span class="comment">// allocate output vector</span>
      <a class="code" href="classcusp_1_1array1d.html">cusp::array1d&lt;float, cusp::host_memory&gt;</a> y(2);
  
      <span class="comment">// compute y = A * x</span>
      <a class="code" href="group__algorithms.html#ga9ebf00a9f894c28ef6cbf01dabd475d1">cusp::multiply</a>(A, x, y);
  
      <span class="comment">// print y</span>
      <a class="code" href="group__utilities.html#ga6eafdd26fcb6819a188b1ab3d282d33a">cusp::print</a>(y);
  
      <span class="keywordflow">return</span> 0;
  }
</pre></div> 
</div>
</div>
<a class="anchor" id="ga4eea276fe0d7ae5048e28e3507bdd472"></a><!-- doxytag: member="cusp::subtract" ref="ga4eea276fe0d7ae5048e28e3507bdd472" args="(const Matrix1 &amp;A, const Matrix2 &amp;B, Matrix3 &amp;C)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix1 , typename Matrix2 , typename Matrix3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cusp::subtract </td>
          <td>(</td>
          <td class="paramtype">const Matrix1 &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix2 &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix3 &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>add</code> : Compute the difference of two matrices </p>

</div>
</div>
<a class="anchor" id="ga9480a952c060ef793a8f84227f1df43c"></a><!-- doxytag: member="cusp::transpose" ref="ga9480a952c060ef793a8f84227f1df43c" args="(const MatrixType1 &amp;A, MatrixType2 &amp;At)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cusp::transpose </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&nbsp;</td>
          <td class="paramname"> <em>At</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>transpose</code> : transpose a matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>input matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>At</em>&nbsp;</td><td>output matrix (transpose of A)</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MatrixType1</em>&nbsp;</td><td>matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MatrixType2</em>&nbsp;</td><td>matrix</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>transpose</code>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="transpose_8h.html" title="Matrix transpose.">cusp/transpose.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="array2d_8h.html" title="Two-dimensional array.">cusp/array2d.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="print_8h.html" title="Print textual representation of an object.">cusp/print.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
  {
      <span class="comment">// initialize a 2x3 matrix</span>
      <a class="code" href="classcusp_1_1array2d.html">cusp::array2d&lt;float, cusp::host_memory&gt;</a> A(2,3);
      A(0,0) = 10;  A(0,1) = 20;  A(0,2) = 30;
      A(1,0) = 40;  A(1,1) = 50;  A(1,2) = 60;
  
      <span class="comment">// print A</span>
      <a class="code" href="group__utilities.html#ga6eafdd26fcb6819a188b1ab3d282d33a">cusp::print</a>(A);
  
      <span class="comment">// compute the transpose</span>
      <a class="code" href="classcusp_1_1array2d.html">cusp::array2d&lt;float, cusp::host_memory&gt;</a> At;
      <a class="code" href="group__algorithms.html#ga9480a952c060ef793a8f84227f1df43c">cusp::transpose</a>(A, At);
  
      <span class="comment">// print A^T</span>
      <a class="code" href="group__utilities.html#ga6eafdd26fcb6819a188b1ab3d282d33a">cusp::print</a>(At);
  
      <span class="keywordflow">return</span> 0;
  }
</pre></div> 
</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon May 30 15:12:24 2011 for cusp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
